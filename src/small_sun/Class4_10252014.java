package small_sun;

public class Class4_10252014 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	/*
	 * Q1   Given a Binary Tree, print Right view of it. 
	 * Right view of a Binary Tree is set of nodes visible when tree is visited from Right side.
	 * 
	 * (1) level order
	 * (2) like the preOrder traverse recursion. 
	 */
	
	
	/*
	 * Q2:   Given a binary tree, print it vertically. 
	 * The following example illustrates vertical order traversal.
	 * 
	 * implement
	 */
	
	/*
	 * Q3:   设有N堆沙子排成一排,其编号为1,2,3,...,N(N<=100)。每堆沙子有一定的数量。
	 * 现要将N 堆沙子并成为一堆。归并的过程只能每次将相邻的两堆沙子堆成一堆(每次合并花费的代价为 当前两堆沙子的总数量),
	 * 这样经过N­1次归并后成为一堆,归并的总代价为每次合并花费的 代价和。找出一种合理的归并方法,使总的代价最小。
	 * 例如:有3堆沙子,数量分别为13,7,8,有两种合并方案, 
	 * 第一种 方案: 先合并1,2号堆,合并后的新堆沙子数量为20,本次合并代价为20,
	 * 再拿新堆与 第3堆沙子合并,合并后的沙子数量为28,本次合并代价为28,
	 * 将3堆沙子合并到一起的总代价 为第一次合并代价20加上第二次合并代价28,即48; 
	 * 第二种方案:先合并2,3号堆, 合并后的新堆沙子数量为15,本次合并代价为15,
	 * 再拿新堆与 第1堆沙子合并,合并后的沙子数量为28,本次合并代价为28,
	 * 将3堆沙子合并到一起的总代价 为第一次合并代价15加上第二次合并代价28,即43; 采用第二种方案可取得最小总代价,值为43。
	 * 
	 * review DP
	 */
	
	

}
